CPU, 입출력 장치, 프로세스 등 컴퓨터 시스템의 자원을 관리하여 컴퓨터 시스템이 제대로 작동하도록 합니다. 이외에도 처리능력 향상, 반환 시간 단축, 신뢰도 향상 등이 있습니다.

- 처리능력: 일정 시간 내에 시스템이 처리하는 일의 양

- 신뢰도: 시스템이 주어진 문제를 정확하게 해결하는 정도

- 반환 시간: 일정 시간 내에 시스템이 처리하는 일의 양

  

### 3. 프로세스

컴퓨터에서 실행 중인 프로그램을 프로세스라고 합니다. 실행 파일이 메모리에 적재될 때, 프로그램이 프로세스로 바뀝니다.
![img](https://velog.velcdn.com/images%2Fjeewoo1025%2Fpost%2Fe96d6da8-af08-47a6-a3bc-cc981ec414a8%2Fimage.png)

#### 3-1. 프로세스의 특징을 설명하시오

프로세스는 각각 독립된 메모리 영역(Stack, Heap, Data, Code)을 할당받는다. 프로세스당 최소 1개의 스레드를 가지고 있다. 각 프로세스는 별도의 주소 공간에서 실행되며, 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 만약 접근하기 위해서는 IPC를 사용해야 한다.
![img](https://velog.velcdn.com/images%2Fjeewoo1025%2Fpost%2F2823d66a-1663-43c5-9d2b-b9f1bbe88a2b%2Fimage.png)

#### ※ Process State

프로세스는 진행되면서 그 상태가 변한다.
![img](https://velog.velcdn.com/images%2Fjeewoo1025%2Fpost%2Fb4f336d3-c439-49e9-b76e-e4169bcd9a24%2Fimage.png)

- **new**: 프로세스가 생성 중이다

- **ready**: 프로세스가 프로세서에 할당되기를 기다리고 있는 상태. 프로세스는 ready 큐에서 실행을 준비하고 있다.

- **running**: ready 큐에 있는 프로세스가 프로세서에 할당받아 실행되는 상태

- **waiting**: 프로세스에 입출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입출력 처리가 완료될 때까지 대기하고 있는 상태

- **terminated**: 프로세스의 실행이 끝나고 프로세스 할당이 해지된 상태

  

#### ※ IPC (Inter-Process Communication)

커널 영역에서 IPC를 사용하여 프로세스들 간에 통신을 제공한다.

- **Pipe** : 2개의 프로세스를 연결하고 하나의 프로세스는 데이터를 쓰기만 하고 다른 프로세스는 데이터를 읽기만 한다.

- **Message Queue** : FIFO 자료구조를 가지는 통신 설비로 커널에서 관리한다. 장점은 비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리할 수 있다. 단점은 데이터가 많이 쌓일수록 추가적인 메모리 자원이 필요하다

- **Shared memory** : 프로세스가 공유 메모리 할당을 커널에 요청하면 해당 프로세스에 메모리 공간을 할당해주고 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다. 장점은 중개자 없이 곧바로 메모리에 적용할 수 있기 때문에 모든 IPC 중 가장 빠르다. 단점은 메시지 전달 방식이 아니기 때문에 데이터를 읽어야 하는 시점을 알 수 없습니다.

  

### 4. 스레드는 무엇인가?

스레드는 프로세스 내에서 실제로 작업을 수행하는 주체를 의미합니다. 모든 프로세스에는 한 개 이상의 스레드가 존재하며 작업을 수행합니다. 또한, 2개 이상의 스레드를 가진 프로세스를 멀티 스레드 프로세스라고 합니다.
![img](https://velog.velcdn.com/images%2Fjeewoo1025%2Fpost%2Fbff1f3b0-bfac-4b3e-9729-81edfc35463a%2Fimage.png)

#### 4-1. 스레드의 특징은?

스레드는 프로세스 내에서 각각 Stack만 할당받고 Code, data, heap 영역은 공유합니다.

#### 4-2. 프로세스와 스레드의 차이는?

프로세스는 실행 중인 프로그램으로 다른 프로세스와 상관없이 독립적으로 메모리 공간을 할당 받지만 스레드는 경량화된 프로세스로 프로세스 안의 제어 흐름이다. 각 스레드는 별도의 레지스터와 스택을 갖고, 힙 영역은 공유한다.

#### 4-3. 스레드의 장점은?

운영체제는 자원을 효율적으로 사용하려고 합니다. 스레드를 사용하면 프로세스보다 생성할 때 오버헤드도 적고 공유된 자원에 대해서도 오버헤드가 적습니다.

#### 4-4. multi-threading의 장단점은?

멀티 스레딩이란 하나의 프로세스를 다수의 스레드를 만들어 실행하는 것입니다.

- 장점
  프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우, 메모리 공간과 시스템 자원 소모가 줄어들게 됩니다. 스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap을 이용하여 데이터를 주고받을 수 있습니다.

- 단점
  멀티 스레딩은 데이터와 힙 영역을 공유하기 때문에 동기화 문제에 신경써야 합니다. 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 엉뚱하게 접근하여 이상한 값을 읽어오거나 수정할 수 있습니다. 그러므로 동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤해야 합니다.

  

#### 4-5. 멀티 스레드 vs 멀티 프로세스

멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수도 있다는 점과 동기화 문제를 안고 있습니다.
반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다.



#### 4-6. 멀티 프로세싱과 멀티 프로그래밍의 차이는 무엇인가?

멀티 프로세싱은 여러 개의 CPU를 장착하여 동시에 여러 작업을 병렬로 실행하는 방법이고
멀티 프로그래밍은 단일 CPU 상에서 여러 개의 프로그램이 동시에 실행되는 것을 말합니다.



#### 4-7. 커널 수준 스레드와 사용자 수준 스레드의 각각 장단점은?

- 커널 수준 스레드
  운영체제 시스템 내에서 생성되어 동작하는 스레드로, 커널이 직접 관리합니다.

- 사용자 수준 스레드
  커널 레벨 밖에 있는 스레드로, 스레드를 관리하는 라이브러리로 인해 사용자 단에서 생성 및 관리되는 스레드입니다.

  

### 5. 소켓이란 무엇인가?

네트워크를 경유하는 프로세스 간 통신의 end point(접속점)으로, 소켓을 통해 client와 server 프로그램 간 데이터를 송수신할 수 있습니다.



### 6. 커널이란 무엇인가?

커널은 메모리에 상주하는 운영체제의 일부분으로 운영체제의 핵심적인 부분을 의미합니다.
운영체제처럼 규모가 큰 프로그램이 전원이 켜질 때마다 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할 것입니다. 따라서 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 load해서 사용합니다.



### 7. 힙 영역과 스택 영역의 차이점을 설명하시오.

- 힙: 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다. 런타임에 크기가 결정됩니다.

- 스택: 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역으로 함수의 호출과 함께 할당됩니다. 컴파일 타임에 크기가 결정됩니다.

  

### 8. 메모리 단편화란 무엇인가?

메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 사용이 불가능한 상태를 메모리 단편화가 발생했다고 합니다.

#### 8-1. 내부 단편화와 외부 단편화란?

- 내부 단편화
  메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 현상
  ![img](https://velog.velcdn.com/images%2Fjeewoo1025%2Fpost%2Fda0eefdf-7a9f-4223-bb4e-7c7ba0c115e6%2Fimage.png)

- 외부 단편화
  메모리가 할당/해제 작업의 반복으로 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 현상
  ![img](https://velog.velcdn.com/images%2Fjeewoo1025%2Fpost%2Ff4967d84-9956-4594-840d-a7bd9c370c21%2Fimage.png)

  

### 9. virtual memory란 무엇인가?

가상 메모리 기법은 물리적 메모리보다 더 큰 프로그램이 실행될 수 있도록 컴퓨터 시스템에서 사용하는 메모리 관리 기법입니다.

#### 9-1. virtual address를 physical address로 변환하는 방법은?

CPU가 메모리 참조를 실행할 때는 MMU(Memory Management Unit)라는 HW 장치를 이용해 해당 가상 주소를 실제 메인 메모리의 물리 주소로 변환하여 메모리 참조를 진행합니다.

#### 9-2. 가상 메모리는 왜 필요한가?

먼저, 메인 메모리를 효율적으로 사용할 수 있습니다. 가상 메모리 시스템에서는 각 프로그램이 사용하는 가상 주소 공간을 우선 디스크에 저장해두고, 그중에서 자주 사용되는 부분만 메인 메모리로 가져와서 사용됩니다.
다음으로, 메모리 관리를 단순화합니다. 가상 메모리 시스템에서는 각 프로세스가 완전히 동일한 포맷의 가상 주소 공간을 가집니다. 이것이 가능한 이유는 실제로 메모리 참조를 수행할 때는 가상 주소를 물리 주소로 변환하는 작업이 진행되기 때문이니다.
마지막으로, 메모리 보호 메커니즘을 단순화합니다. 가상 메모리 시스템에서는 다른 프로세스의 주소 공간이 접근하는 것을 쉽게 막을 수 있습니다.



### 10. 페이징의 정의와 장단점을 설명하시오.

![img](https://velog.velcdn.com/images%2Fjeewoo1025%2Fpost%2Fd61dbc17-d461-41b3-a5fe-5477bbb2a6d7%2Fimage.png)

- 페이지(Page): 일정한 크기를 가진 블록
- 페이징(paging): virtual memory를 page로 나누는 기법. 프로세스의 물리 주소 공간이 연속되지 않아도 됨.
- 페이지 테이블 : 가상 페이지와 물리 페이지 사이의 맵핑 정보를 담은 테이블
- Demand paging : 요구된 page만을 메인 메모리에 적재한다. 사용되지 않는 page를 메모리에 적재하는 것을 예방하고 교체시간, 메모리 공간을 절약한다

Page table을 사용하여 논리 메모리를 실제 물리 메모리로 변환하는 과정을 거쳐 실제 메모리에 접근한다. 일반적으로 물리 메모리는 동일한 크기의 frame으로 논리메모리는 동일한 크기의 page로 나눈다

- 장점 : 메모리를 page 단위로 가져와 프로세스의 효율적인 운영이 가능합니다

- 단점 : page별로 page fault 현상이 발생할 수 있습니다. (page fault : page를 읽어오려고 했는데 실패함. 즉, page가 physical memory에 없다)

  

#### 10-1. 운영체제에서 페이징을 왜 사용할까?

페이징은 연속 메모리 할당 문제인 외부 단편화를 피할 수 있게 합니다.

#### 10-2. 세그멘테이션(segmentation)이란?

페이징 기법에서는 가상 메모리를 같은 크기의 단위로 분할 했지만, 세그멘테이션 기법에서는 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당합니다. 각 세그먼트는 연속적인 공간에 저장되어 있고 크기가 다르기 때문에 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법입니다.

#### 10-3. 메인 메모리에 접근하려면 page table를 이용해야 하는데 page table이 메인 메모리에 있으면 어떻게 이용하냐?

그래서 page table의 위치와 크기는 레지스터가 가지도록 합니다.

#### 10-4. TLB(Translation Lookaside Buffer)를 사용하는 이유는?

TLB는 최근에 Translation 했던 정보를 담는 버퍼입니다. 해당 버퍼는 캐시 역할을 하며 최근에 접근한 page에 대한 물리적 주소를 저장해놓습니다. 만약 해당 정보에 Translation 정보가 있다면 Main Memory를 access하지 않아도 되어 비용을 줄일 수 있습니다. 즉, 메인메모리의 page table 접근하는 과정을 줄이는 것입니다.



### 11. Deadlock(교착상태)란?

2개 이상의 프로세스나 스레드가 서로 자원을 기다리면서 무한히 기다리게 되는 상태입니다

#### 11-1. 교착상태의 4가지 조건은 무엇인가?

1. 상호배제 : 한 자원에 대한 여러 프로세스의 동시 접근은 불가능하다

2. 점유와 대기 : 하나의 자원을 소유하고 다른 프로세스 또는 스레드의 자원을 요청하는 상태이다

3. 비선점(Non preemptive): 다른 프로세스에서 자원을 사용하는 동안 자원을 강제로 가져올 수 없다

4. 환형 대기: 각 프로세스가 다음 프로세스가 요구하는 자원을 가지고 있는 상태이다.

   

#### 11-2. 교착상태의 해결방법은?

1. 예방 : 교착상태가 발생하지 않도록 하는 것

2. 회피 : 교착상태를 피하는 것 ex) Banker’s algorithm

3. 탐지 : 교착상태가 발생하면 탐지하는 것

4. 복구 : 프로세스를 중지하고 자원을 선점

   

#### 11-3. Banker’s algorithm은 무엇인가?

프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하여 교착 상태를 회피하는 기법입니다. 안정 상태에 있으면 자원을 할당하고, 그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기합니다.



### 12. RAID의 종류에 대해 말하시오

RAID는 Redundant Array of Independent Disk의 약자입니다. 디스크는 메모리, CPU에 비해 망가지기 쉽기 때문에 데이터의 손상 방지를 위해 사용됩니다.
• RAID 0-내결함성이없는 스트립 디스크 어레이
• RAID 1-미러링 및 이중화
• RAID 2-메모리 스타일 오류 수정 코드
• RAID 3-비트 인터리브 패리
• RAID 4-블록 인터리브 패리티
• RAID 5-블록 인터리브 분산 패리티
• RAID 6-P + Q 이중화



### 13. Sync와 Async의 차이는 무엇인가?

Sync (동기) : 메소드를 실행시킨 뒤 값을 반환할 때까지 기다리는 경우를 동기라고 합니다
Async (비동기) : 그렇지 않은 경우는 비동기라고 합니다.



### 14. 스풀링(Spooling)이란 무엇인가?

스풀링은 장치 또는 시스템에서 데이터를 사용하고 실행하기 위해 일시적으로 데이터를 수집하는 프로세스이다. 예를 들어, 다른 응용 프로그램이 동시에 출력을 프린터에 보내면 스풀링은 이러한 모든 작업을 디스크 파이렝 보관하고 프린터에 따라 대기열에 넣는다.



### 15. 뮤텍스란 무엇인가?

뮤텍스는 1개의 Lock만을 갖는 Locking 매커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 critical section에 들어올 수 있습니다. 그리고 오직 이 쓰레드만이 critical section을 나갈 때 뮤텍스를 해제할 수 있습니다.

- Critical section : 임계 구역. 공유되는 자원, 즉 동시에 접근하려고 하는 자원에 문제가 발생하지 않게 독점을 보장하는 영역

  

#### 15-1. 세마포어란 무엇인가?

세마포어는 signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 보내 락을 해제할 수 있습니다. Wait 함수를 호출하면 세마포어 count를 1 줄이고, 세마포어의 count가 0 이하이면 락이 실행됩니다.



#### 15-2. 뮤텍스와 세마포어의 차이는?

뮤텍스와 세마포어는 모두 동기화를 위해 이용되는 도구입니다. 뮤텍스는 Locking 알고리즘으로 락을 걸은 쓰레드만이 critical section을 나갈 떄 락을 해제할 수 있습니다. 하지만 세마포어는 signaling 메커니즘으로 락을 걸지 않은 쓰레드도 signal을 사용해 락을 해제할 수 있습니다. 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 활용할 수 있습니다.



### 16. 운영체제에서 기아(starvation)이란 무엇인가?

특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태입니다.



### 17. 운영체제에서 에이징(Aging)는 무엇인가?

스케줄링 시스템에서 기아를 방지하기 위해 사용되는 기술입니다. 특정 프로세스의 우선순위가 낮아 무한정 기다리게 되는 경우, 한 번 양보하거나 기다린 시간에 비례하여 일정시간이 지나면 우선순위를 한 단계씩 높여 가까운 시간 내에 자원을 할당받도록 합니다.



### 18. CPU Scheduling이란?

프로세스가 작업을 수행할 때 언제 어떤 프로세스에 CPU를 할당할지를 결정하는 작업입니다. 기본적으로 멀티 프로그래밍과 time-sharing에 기반합니다.



#### 18-1. CPU Scheduling은 언제 발생하는가?

Running 상태에서 ready 상태로 전환될 때 (ex. Interrupt가 발생하는 경우)
Running 상태에서 waiting 상태로 전환될 때 (ex. 입출력을 요청하는 경우)
종료될 때 (Terminated)
Waiting 상태에서 ready 상태로 전환될 때 (ex. 입출력이 종료되는 경우)



#### 18-2. CPU 스케줄링 종류를 설명하시오.

- **비선점(Non-preemptive) 스케줄링**
  이미 할당된 CPU를 다른 프로세스가 선점하여 사용할 수 없는 스케줄링 기법
  프로세스가 CPU를 할당 받으면 끝날 때 까지 기다린다.
  **FCFS** : ready 큐에 도착한 순서에 따라 CPU를 할당하는 기법
  **SJF** : Shortest Job First, 실행 시간이 가장 짧은 프로세스에게 CPU를 할당하는 기법
  우선순위 : 우선순위가 가장 높은 프로세스부터 먼저 CPU를 할당하는 기법

- **선점(Preemptive) 스케줄링**
  하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 프로세스가 CPU를 선점하여 사용할 수 있는 스케줄링 기법
  **Round Robin** : 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위로 CPU를 할당하는 스케줄링 기법. (FCFS에 time-sharing 방식 추가한 것)

  

#### 18-3. 선점 스케줄링과 비선점 스케줄링의 차이점은?

![img](https://velog.velcdn.com/images%2Fjeewoo1025%2Fpost%2Fdf9010a1-9b74-46d3-8fdd-27caebaded8c%2Fimage.png)

#### 18-4. Context Switching이란?

프로세스 상태를 변경하는 것을 말합니다. 스케줄러에 의해 실행 중인 코드, 자원 등을 저장하고 현재 상태를 대기 상태로 전환한 뒤 다른 프로세스를 실행시키는 과정입니다.



### 19. 컴퓨터가 부팅되는 과정을 설명하시오.

1. 컴퓨터의 전원이 들어온다. (On)

2. CPU에선 메모리의 0번지 주소를 읽는다. 메모리 0번지에는 ROM이라는, 컴퓨터를 구동하기 위한 기본 정보가 담긴 메모리가 있다. (ROM은 비휘발성 메모리이다)

3. ROM에서 읽어들인 내용을 바탕으로 하드웨어 상태를 확인한다. (POST - Power On Self Test 수행)

4. OS를 로드하기 위해 Disk의 첫번째 섹터인 MBS(Master Boot Record)를 읽는다. 이 MBR에서 부트 코드(Boot code)가 실행된다.

5. 부트 코드는 부팅 가능한 파티션을 찾아 해당 파티션의 부트 레코드를 호출하고, 해당 파티션 부트 레코드는 RAM에 적재하여 실행한다.

6. 해당 파티션으로 부팅이 시작된다.

   

### 20. 디스크에 파일을 write하던 중 컴퓨터 전원이 off될 수 있습니다. 이를 보완하기 위해 존재하는 방법이 있나요?

저널링 (log에 데이터를 기록함)